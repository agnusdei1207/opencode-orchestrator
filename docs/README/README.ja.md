# OpenCode Orchestrator Plugin (JA)

> **[OpenCode](https://opencode.ai)のためのマルチエージェントコラボレーションプラグイン**

[![MIT License](https://img.shields.io/badge/license-MIT-blue.svg)](../../LICENSE)
[![npm](https://img.shields.io/npm/v/opencode-orchestrator.svg)](https://www.npmjs.com/package/opencode-orchestrator)
[![npm downloads](https://img.shields.io/npm/dt/opencode-orchestrator.svg)](https://www.npmjs.com/package/opencode-orchestrator)
[![OpenCode Plugin](https://img.shields.io/badge/OpenCode-Plugin-purple.svg)](https://opencode.ai)

[English](../../README.md) | [한국어](README.ko.md) | [简体中文](README.zh.md) | [日本語](README.ja.md) | [Español](README.es.md) | [Français](README.fr.md) | [Deutsch](README.de.md)
[Русский](README.ru.md) | [Português](README.pt.md)

---

<p align="center">
  <img src="../../assets/logo.png" width="600" />
</p>

> **究極の目標**
>
> 非常に小さな単位に業務を分割し、**愚か者でも遂行できるようにして**、**並列で協業できるようにすること**です。モデルが賢い必要はありません. **協力する方法が完璧であればよいのです。**

---

## これは何ですか？

6つのエージェントが協力して、**エージェントオーケストレーション**を最大化し、**手頃な価格の低性能モデル**から**究極の意思決定品質 (Ultimate Decision Quality)**を引き出すシステムです。

**核心となるアイデア**: 戦略的な役割分担、タスクのマイクロ単位への分解、そして厳格な検証ルールの強制を通じて、**「安価なモデル」のコストで「高価なモデル」の成果**を達成します。モデル自体の性能が最上級でなくとも、このアーキテクチャは**素晴らしい結果**を必ずやり遂げます。

---

## なぜ Orchestrator なのか？

| 従来の方法 | Orchestrator を使用 |
|-------------|-------------------|
| 高価で「賢い」モデルが必須 | **手頃なモデル + 賢いプロセス** |
| 高いトークンコスト (巨大なコンテキスト) | **トークン効率** (フィルタリングされたコンテキスト) |
| 線形で遅い実行 | **並列で高速な実行** |
| エラーが静かに蓄積する | **自己修正検証ループ** |
| 「動くことを祈る」 | **戦略的マイクロタスク化** |

---

- **🧩 戦略的組織化** — インテリジェントな役割配分による出力の最大化
- **📉 トークンエコノミー** — ノイズをフィルタリングしてコスト削減と集中力向上
- **⚡ 並列 DAG** — 速度と効率のための同時実行
- **🔍 マイクロタスク化** — 幻覚（ハルシネーション）を防ぐための原子単位の分解
- **🛡️ スタイルガーディアン** — 厳格な AST ベースのリンティングと一貫性チェック
- **🔄 セルフヒーリング** — 複雑なエラーに対する自律的な回避戦略
- **🏗️ Rust コア** — 重い処理のためのネイティブパフォーマンスバイナリ

---

## 仕組み (並列DAG)

線形な順序の代わりに、**有向非巡回グラフ (DAG)** を使用してミッションをモデル化します。

```
      ミッション開始 (/task)
              │
              ▼
      ┌───────────────┐
      │   PLANNER     │ (設計者)
      └───────┬───────┘
              │
      ┌───────┴───────┐
      │               │ (並列ストリーム)
      ▼               ▼
 ┌───────────┐   ┌───────────┐
 │ タスク (A) │   │ タスク (B) │
 └─────┬─────┘   └─────┬─────┘
       │               │
       └───────┬───────┘
               ▼
       ┌───────────────┐
       │   REVIEWER    │ (スタイルガーディアン)
       └───────┬───────┘
               ▼
           ✅ ミッション完了
```

---

## インストール方法

**npm** または **bun** を使用できます。コアロジックはネイティブの **Rustバイナリ** で実行されるため、どちらも同様に動作します。

### 方法 1: npm (標準)
```bash
npm install -g opencode-orchestrator
```

### 方法 2: Bun (高速)
```bash
bun install -g opencode-orchestrator
```

> **注意**: インストール後、**OpenCodeを再起動**するか、ターミナルで `opencode` を実行してください。
> プラグインは `~/.config/opencode/opencode.json` に絶対パスとともに自動的に登録されます。

### トラブルシューティング
`/dag` コマンドが表示されない場合:
1. 削除: `npm uninstall -g opencode-orchestrator` (または `bun remove -g`)
2. 設定クリア: `rm -rf ~/.config/opencode` (警告: すべてのプラグイン設定がリセットされます)
3. 再インストール: `npm install -g opencode-orchestrator`

---

**必要なコマンドはこれだけです:**

```bash
/dag "JWTを使用したユーザー認証を実装して"
```

オーケストレーターが実行すること:
1. **分解 (Decompose)**: ミッションをJSONタスクDAGに分解
2. **並列実行 (Parallel Execute)**: 独立したストリームを同時に実行
3. **検索 (Search)**: コードパターンを積極的に探索
4. **コーディング (Code)**:原子的な精度でコードを作成
5. **検証 (Verify)**: スタイルガーディアンによる必須検証
6. **自己修復 (Self-Heal)**: エラーが発生した場合に自動修正

---

## エージェント構成

| エージェント | 役割 |
|--------------|------|
| **Orchestrator** | チームリーダー — 調整、決定、戦略修正 |
| **Planner** | 作業を原子的な単位に分解 |
| **Coder** | 一度に1つのタスクを実装 |
| **Reviewer** | 品質ゲート — すべてのエラーと同期を監視 |
| **Fixer** | 目標を絞ったエラー修正 |
| **Searcher** | コーディング前のコンテキストとパターンの探索 |

---

- [アーキテクチャ詳細](docs/ARCHITECTURE.md) — DAGの仕組み
- [設定ガイド](../../examples/orchestrator.jsonc) — 設定のカスタマイズ

---

## オープンソース

MITライセンス。テレメトリなし。バックドアなし。

[github.com/agnusdei1207/opencode-orchestrator](https://github.com/agnusdei1207/opencode-orchestrator)

---

## ライセンス

MIT License. NO WARRANTY.

[MIT](../../LICENSE)

---

## 🏛️ プロジェクト哲学: オーケストレーションによるコスト効率

私たちは、**組織力がモデルのサイズに勝る**と信じています。優れたコードを書くために月額100ドルのAPIは必要ありません。必要なのは、より良い**プロセス**です。

このプロジェクトは、正しく組織化されれば、**手頃な低性能モデル**（ローカルモデルや格安APIなど）でも**究極の意思決定品質**を達成できることを証明します。私たちは、優秀な人間によるエンジニアリングチームを模倣することでこれを実現します。

### 秘訣: 極限の効率性

1.  **マイクロタスク化 (「分散」戦略)**: モデルに「Webサイトを作って」と頼むことはしません。作業を20行程度の原子的な変更に細分化します。小さなコンテキスト = 高い精度 = 低い幻覚 (Hallucination)。
2.  **並列処理**: 複数のエージェントが異なるファイルで同時に作業します。スレッドの並行性を実時間の短縮に変えます。
- **PDCAサイクルの遵守**: 計画-実行-評価-改善の厳格なループを通じて品質を保証します。
- **🔍 マイクロタスク化 (Micro-tasking)**: 幻覚（Hallucination）を防ぐためにタスクを原子単位に分解します。
- **🛡️ スタイルガーディアン (Style Guardian)**: Reviewerが厳格なASTベースのLintと一貫性チェックを実行します。
- **🔄 自己修復 (Self-healing)**: 複雑なエラーに対する自律的な回避戦略。
- **分散認知システム**: 単なるチャットボットではなく、OSカーネルのように動作するインテリジェンスレイヤー。
- **ファイルベースの状態管理**: コンテキストウィンドウに依存せず、物理ファイルシステムをRAMのように活用します。エージェントはコードベース全体を読むのではなく、*変更点*と*要約*のみを読みます。これにより、精度を維持しながらトークンコストを大幅に削減します。
- **容赦ない検証**: 安価なモデルは間違いを犯すことを受け入れます。**Reviewer**エージェントは、その間違いを捕捉するためにのみ存在します。100%の信頼性のために、わずかな計算時間を投資します。

### 🚀 コマンド: `/task`

この力を利用するためのインターフェースは、単一の直感的なコマンドです：

```bash
/flow "認証ミドルウェアをリファクタリングし、JWTローテーションを実装して"
```

これは **「オペレーショナル・フロー (Operational Flow)」** を保証します。それは、意図から実現へと流れる知的な行動の流れを意味し、厳格で自己修正可能なグラフによって管理されます。

### 5段階の効率化ワークフロー

1.  **🧠 フェーズ 1: フィルタリングされた分析**: **Searcher**はドキュメントを読みますが、ノイズを除去します。「クリティカルパス」のみをPlannerに渡します。
2.  **🌲 フェーズ 2: 戦略的計画**: **Planner**はJSON DAGを作成します。これが私たちのロードマップです。あてもなくさまようことにトークンは浪費されません。
3.  **🚀 フェーズ 3: 並列実行**: **Orchestrator**は独立したタスクを特定し、同時に実行します。
4.  **🛡️ フェーズ 4: 同期と検証**: **Reviewer**は門番の役割を果たします。構文、ロジック、そして*ファイル間の一貫性*をチェックします。
5.  **💰 フェーズ 5: コスト効率の良い完了**: 「ジュニアインターン」の価格で「シニア開発者」の結果を得ます。

---

## ⚡ 高速な開発速度

このプロジェクトは**非常に速く**進化しています。あなたのワークフローに完璧な実行力をもたらすために、日々繰り返し改善されています。
アップデートが頻繁に行われるため、常に最新バージョンを維持してください。
