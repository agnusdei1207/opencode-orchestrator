# OpenCode Orchestrator í†µí•© ê°œì„ ì•ˆ

> **ì‘ì„±ì¼**: 2026-01-27
> **í˜„ì¬ ë²„ì „**: 1.2.21  
> **ëª©í‘œ**: OpenCode ë„¤ì´í‹°ë¸Œ API í™œìš© + ë¬´í•œ ë£¨í”„ ë³´ì¥ + ë³‘ë ¬ ê°•í™” + ì•ˆì „í•œ ë¦¬ì†ŒìŠ¤ íšŒìˆ˜

---

## ğŸ“‹ ëª©ì°¨

1. [í˜„ì¬ ìƒíƒœ ë¶„ì„](#1-í˜„ì¬-ìƒíƒœ-ë¶„ì„)
2. [í•µì‹¬ ê°œì„  ëª©í‘œ](#2-í•µì‹¬-ê°œì„ -ëª©í‘œ)
3. [OpenCode API í™œìš©](#3-opencode-api-í™œìš©)
4. [ë¬´í•œ ë£¨í”„ ë³´ì¥ ì‹œìŠ¤í…œ](#4-ë¬´í•œ-ë£¨í”„-ë³´ì¥-ì‹œìŠ¤í…œ)
5. [ë³‘ë ¬ ì²˜ë¦¬ ê°•í™”](#5-ë³‘ë ¬-ì²˜ë¦¬-ê°•í™”)
6. [ì•ˆì „í•œ ë¦¬ì†ŒìŠ¤ íšŒìˆ˜](#6-ì•ˆì „í•œ-ë¦¬ì†ŒìŠ¤-íšŒìˆ˜)
7. [êµ¬í˜„ ê³„íš](#7-êµ¬í˜„-ê³„íš)

---

## 1. í˜„ì¬ ìƒíƒœ ë¶„ì„

### 1.1 ë¯¸ì…˜ ë£¨í”„ (í˜„ì¬ êµ¬í˜„)

**íŒŒì¼**: `src/core/loop/mission-loop.ts`, `todo-continuation.ts`, `mission-loop-handler.ts`

```typescript
// í˜„ì¬ ë¬¸ì œ: maxIterations ì œí•œìœ¼ë¡œ ë¬´í•œ ë£¨í”„ê°€ ì•„ë‹˜
const DEFAULT_MAX_ITERATIONS = MISSION_CONTROL.DEFAULT_MAX_ITERATIONS; // ê¸°ë³¸ 100

export function startMissionLoop(directory, sessionID, prompt, options = {}) {
  const state = {
    maxIterations: options.maxIterations ?? DEFAULT_MAX_ITERATIONS,  // âŒ ì œí•œ ìˆìŒ!
    // ...
  };
}
```

**í˜„ì¬ ìƒíƒœ:**
- âœ… ë¯¸ì…˜ ë£¨í”„ ê¸°ë³¸ êµ¬ì¡° ì¡´ì¬
- âœ… Todo ì™„ë£Œ ì²´í¬ ë¡œì§ ì¡´ì¬
- âœ… Continuation í”„ë¡¬í”„íŠ¸ ì£¼ì… ì¡´ì¬
- âŒ **maxIterations ë„ë‹¬ ì‹œ ì¢…ë£Œ** (ë¬´í•œ ì•„ë‹˜)
- âŒ **ë¬´í•œ ëª¨ë“œ ì˜µì…˜ ì—†ìŒ**

### 1.2 ë³‘ë ¬ ì²˜ë¦¬ (í˜„ì¬ êµ¬í˜„)

**íŒŒì¼**: `src/core/agents/manager.ts`, `session-pool.ts`, `unified-task-executor.ts`

```typescript
// í˜„ì¬ êµ¬í˜„: ì—ì´ì „íŠ¸ë³„ ë™ì‹œì„± ì œí•œ
const DEFAULT_CONFIG = {
  maxPoolSizePerAgent: 5,      // ì—ì´ì „íŠ¸ë‹¹ ìµœëŒ€ 5ê°œ ì„¸ì…˜
  idleTimeoutMs: 300_000,      // 5ë¶„ ìœ íœ´ íƒ€ì„ì•„ì›ƒ
  maxReuseCount: 10,           // ì„¸ì…˜ë‹¹ ìµœëŒ€ 10íšŒ ì¬ì‚¬ìš©
};
```

**í˜„ì¬ ìƒíƒœ:**
- âœ… SessionPoolë¡œ ì„¸ì…˜ ì¬ì‚¬ìš©
- âœ… ConcurrencyControllerë¡œ ë™ì‹œì„± ì œì–´
- âš ï¸ ì—ì´ì „íŠ¸ë³„ ê³ ì • ì œí•œ (ë™ì  ì¡°ì • ì—†ìŒ)
- âŒ **ì ì‘í˜• ë™ì‹œì„± ì¡°ì ˆ ì—†ìŒ**
- âŒ **ìë™ ìŠ¤ì¼€ì¼ë§ ì—†ìŒ**

### 1.3 ë¦¬ì†ŒìŠ¤ íšŒìˆ˜ (í˜„ì¬ êµ¬í˜„)

**ë¶„ì‚°ëœ cleanup í•¨ìˆ˜ë“¤:**

```
src/core/loop/todo-continuation.ts     â†’ cleanupSession()
src/core/loop/mission-loop-handler.ts  â†’ cleanupSession()
src/core/loop/continuation-lock.ts     â†’ cleanupContinuationLock()
src/core/session/session-health.ts     â†’ cleanupSessionHealth()
src/core/agents/unified-task-executor.ts â†’ cleanup()
src/core/agents/session-pool.ts        â†’ cleanup(), shutdown()
src/core/agents/manager.ts             â†’ cleanup()
src/core/cleanup/cleanup-scheduler.ts  â†’ compactWAL(), cleanDocs(), rotateHistory()
```

**í˜„ì¬ ìƒíƒœ:**
- âœ… CleanupSchedulerë¡œ ì£¼ê¸°ì  ì •ë¦¬
- âœ… ì„¸ì…˜ë³„ cleanup í•¨ìˆ˜ ì¡´ì¬
- âš ï¸ cleanup í˜¸ì¶œ ë¶„ì‚° (ëˆ„ë½ ê°€ëŠ¥ì„±)
- âŒ **ì¤‘ì•™í™”ëœ ë¦¬ì†ŒìŠ¤ ê´€ë¦¬ ì—†ìŒ**
- âŒ **ë¦¬ì†ŒìŠ¤ ì¶”ì  ë©”ì»¤ë‹ˆì¦˜ ë¶ˆì™„ì „**

---

## 2. í•µì‹¬ ê°œì„  ëª©í‘œ

### 2.1 ëª©í‘œ ìš”ì•½

| ëª©í‘œ | í˜„ì¬ ìƒíƒœ | ê°œì„  ë°©í–¥ |
|------|----------|----------|
| **ë¬´í•œ ë£¨í”„** | maxIterations ì œí•œ (100) | `infinite` ëª¨ë“œ ë„ì…, Todo ë‚¨ìœ¼ë©´ ë¬´ì¡°ê±´ ê³„ì† |
| **ë³‘ë ¬ ê°•í™”** | ì—ì´ì „íŠ¸ë³„ 5ê°œ ì œí•œ | ë™ì  ìŠ¤ì¼€ì¼ë§, ì‘ì—… ê¸°ë°˜ ì¡°ì ˆ |
| **ë¦¬ì†ŒìŠ¤ íšŒìˆ˜** | ë¶„ì‚°ëœ cleanup | ì¤‘ì•™í™”ëœ ResourceTracker |

### 2.2 ì„±ê³µ ê¸°ì¤€

1. `/task` ì‹¤í–‰ ì‹œ **ëª¨ë“  Todo ì™„ë£Œê¹Œì§€ ë¬´í•œ ë°˜ë³µ**
2. ë³‘ë ¬ ì‘ì—… **ìµœì†Œ 10ê°œ ë™ì‹œ ì‹¤í–‰** ê°€ëŠ¥
3. ì„¸ì…˜ ì¢…ë£Œ ì‹œ **ëª¨ë“  ë¦¬ì†ŒìŠ¤ 100% íšŒìˆ˜** ë³´ì¥

---

## 3. OpenCode API í™œìš©

### 3.1 ì‹¤ì œ ì‚¬ìš© ê°€ëŠ¥í•œ SDK API

```typescript
// @opencode-ai/sdk - ì‹¤ì œ ì‚¬ìš© ê°€ëŠ¥í•œ API
const client = createOpencodeClient({ baseUrl: "http://localhost:4096" })

// ì„¸ì…˜ ê´€ë¦¬
await client.session.create()              // ì„¸ì…˜ ìƒì„±
await client.session.get({ sessionID })    // ì„¸ì…˜ ì¡°íšŒ
await client.session.status({ sessionID }) // ì„¸ì…˜ ìƒíƒœ (idle/busy)
await client.session.delete({ sessionID }) // ì„¸ì…˜ ì‚­ì œ â­ ë¦¬ì†ŒìŠ¤ íšŒìˆ˜
await client.session.abort({ sessionID })  // ì„¸ì…˜ ì¤‘ë‹¨

// ë©”ì‹œì§€/í”„ë¡¬í”„íŠ¸
await client.session.prompt({ sessionID, parts })  // ë©”ì‹œì§€ ì „ì†¡

// Todo (ì½ê¸° ì „ìš©)
await client.session.todo({ sessionID })   // Todo ëª©ë¡ ì¡°íšŒ

// ì´ë²¤íŠ¸ êµ¬ë…
await client.global.event()                // SSE ì´ë²¤íŠ¸ ìŠ¤íŠ¸ë¦¼
```

### 3.2 í”ŒëŸ¬ê·¸ì¸ Hooks í™œìš©

```typescript
// Hooks í™œìš© (í˜„ì¬ ì´ë¯¸ ì‚¬ìš© ì¤‘)
const hooks: Hooks = {
  "chat.message": async (ctx, output) => { /* /task ê°ì§€ */ },
  "tool.execute.after": async (ctx, output) => { /* ë„êµ¬ ëª¨ë‹ˆí„°ë§ */ },
  "event": async ({ event }) => { /* ì„¸ì…˜ ì´ë²¤íŠ¸ êµ¬ë… */ },
};
```

### 3.3 Todo ì—…ë°ì´íŠ¸ ë°©ì‹ (ì¤‘ìš”)

**í•µì‹¬**: TodoëŠ” LLMì´ `todowrite` ë„êµ¬ë¥¼ í˜¸ì¶œí•´ì•¼ë§Œ ì—…ë°ì´íŠ¸ ê°€ëŠ¥

```typescript
// âŒ ë¶ˆê°€ëŠ¥ - í”ŒëŸ¬ê·¸ì¸ì—ì„œ ì§ì ‘ í˜¸ì¶œ ë¶ˆê°€
await Todo.update({ sessionID, todos })

// âœ… ê°€ëŠ¥ - LLMì´ ë„êµ¬ë¥¼ í˜¸ì¶œ
// LLM â†’ todowrite({ todos: [...] }) â†’ OpenCode ë‚´ë¶€ ì €ì¥
```

---

## 4. ë¬´í•œ ë£¨í”„ ë³´ì¥ ì‹œìŠ¤í…œ

### 4.1 í˜„ì¬ ë¬¸ì œ

```typescript
// mission-loop.ts - í˜„ì¬ ì½”ë“œ
if (state.iteration >= state.maxIterations) {
  // âŒ ì—¬ê¸°ì„œ ë£¨í”„ê°€ ì¢…ë£Œë¨!
  return generateMaxIterationsNotification(state);
}
```

### 4.2 ê°œì„ ì•ˆ: InfiniteLoopController

```typescript
// src/core/loop/infinite-loop-controller.ts (ì‹ ê·œ, ~200ì¤„)

export interface InfiniteLoopConfig {
  /** ë¬´í•œ ëª¨ë“œ í™œì„±í™” (ê¸°ë³¸: true) */
  infinite: boolean;
  
  /** ìµœëŒ€ ë°˜ë³µ (ë¬´í•œ ëª¨ë“œ ì•„ë‹ ë•Œë§Œ ì ìš©) */
  maxIterations: number;
  
  /** ìµœì†Œ ì§„í–‰ í™•ì¸ ì£¼ê¸° (ìŠ¤í…Œê·¸ë„¤ì´ì…˜ ê°ì§€) */
  stagnationCheckIterations: number;
  
  /** ìŠ¤í…Œê·¸ë„¤ì´ì…˜ ì‹œ ê°œì… íšŸìˆ˜ ì œí•œ */
  maxStagnationInterventions: number;
  
  /** ìê°€ ì¢…ë£Œ í”Œë˜ê·¸ (LLMì´ ì™„ë£Œ ì„ ì–¸ ì‹œì—ë§Œ ì¢…ë£Œ) */
  selfTerminationOnly: boolean;
}

const DEFAULT_INFINITE_CONFIG: InfiniteLoopConfig = {
  infinite: true,           // â­ ê¸°ë³¸ê°’: ë¬´í•œ
  maxIterations: 1000,      // ë¬´í•œ ëª¨ë“œì—ì„œë„ ì•ˆì „ì¥ì¹˜
  stagnationCheckIterations: 3,
  maxStagnationInterventions: 5,
  selfTerminationOnly: false,
};

export class InfiniteLoopController {
  private config: InfiniteLoopConfig;
  private state: LoopState | null = null;
  private client: OpencodeClient;
  private directory: string;

  constructor(client: OpencodeClient, directory: string, config?: Partial<InfiniteLoopConfig>) {
    this.client = client;
    this.directory = directory;
    this.config = { ...DEFAULT_INFINITE_CONFIG, ...config };
  }

  /**
   * ë¯¸ì…˜ ì‹œì‘ - /task ëª…ë ¹ì–´ ì‹œ í˜¸ì¶œ
   */
  async start(sessionID: string, prompt: string): Promise<void> {
    this.state = {
      sessionID,
      prompt,
      iteration: 0,
      stagnationCount: 0,
      lastProgress: '',
      lastTodoHash: '',
      startedAt: Date.now(),
      status: 'active',
    };

    this.saveState();
    log(`[InfiniteLoop] Started for ${sessionID} with infinite=${this.config.infinite}`);
  }

  /**
   * ë‹¤ìŒ ë°˜ë³µ ì²´í¬ - session.idle ì´ë²¤íŠ¸ ì‹œ í˜¸ì¶œ
   * 
   * @returns true = ê³„ì† ì§„í–‰, false = ì¢…ë£Œ
   */
  async checkContinuation(): Promise<{ continue: boolean; prompt?: string; reason?: string }> {
    if (!this.state) return { continue: false, reason: 'No active loop' };

    this.state.iteration++;
    
    // 1. Todo ìƒíƒœ í™•ì¸ (OpenCode API ì‚¬ìš©)
    const todos = await this.fetchTodos();
    const incompleteTodos = todos.filter(t => t.status !== 'completed' && t.status !== 'cancelled');
    const todoHash = this.hashTodos(incompleteTodos);

    // 2. ì™„ë£Œ ì¡°ê±´ í™•ì¸: ëª¨ë“  Todo ì™„ë£Œ
    if (todos.length > 0 && incompleteTodos.length === 0) {
      this.state.status = 'completed';
      this.saveState();
      return { continue: false, reason: 'All todos completed' };
    }

    // 3. ë¬´í•œ ëª¨ë“œê°€ ì•„ë‹ˆê³  maxIterations ë„ë‹¬
    if (!this.config.infinite && this.state.iteration >= this.config.maxIterations) {
      this.state.status = 'max_iterations';
      this.saveState();
      return { continue: false, reason: `Max iterations (${this.config.maxIterations}) reached` };
    }

    // 4. ìŠ¤í…Œê·¸ë„¤ì´ì…˜ ê°ì§€
    let intervention: string | undefined;
    if (todoHash === this.state.lastTodoHash) {
      this.state.stagnationCount++;
      if (this.state.stagnationCount >= this.config.stagnationCheckIterations) {
        intervention = this.buildStagnationIntervention(incompleteTodos);
        
        // ìŠ¤í…Œê·¸ë„¤ì´ì…˜ ê°œì… íšŸìˆ˜ ì œí•œ (ë¬´í•œ ë£¨í”„ ë°©ì§€ì˜ ë°©ì§€)
        if (this.state.stagnationCount >= 
            this.config.stagnationCheckIterations * this.config.maxStagnationInterventions) {
          // ê°•ì œ ì¬í‰ê°€ ìš”ì²­
          intervention = this.buildForceReassessPrompt(incompleteTodos);
        }
      }
    } else {
      this.state.stagnationCount = 0;
      this.state.lastTodoHash = todoHash;
    }

    // 5. Continuation í”„ë¡¬í”„íŠ¸ ìƒì„±
    const prompt = this.buildContinuationPrompt(incompleteTodos, intervention);

    this.saveState();
    return { continue: true, prompt };
  }

  /**
   * ê°•ì œ ì¢…ë£Œ
   */
  abort(reason: string): void {
    if (!this.state) return;
    this.state.status = 'aborted';
    this.saveState();
    log(`[InfiniteLoop] Aborted: ${reason}`);
  }

  /**
   * Todo ëª©ë¡ ì¡°íšŒ (OpenCode API)
   */
  private async fetchTodos(): Promise<Todo[]> {
    if (!this.state) return [];
    try {
      const response = await this.client.session.todo({ path: { id: this.state.sessionID } });
      return (response.data ?? []) as Todo[];
    } catch {
      return [];
    }
  }

  /**
   * Continuation í”„ë¡¬í”„íŠ¸ ìƒì„±
   */
  private buildContinuationPrompt(incompleteTodos: Todo[], intervention?: string): string {
    const progress = `[${incompleteTodos.filter(t => t.status === 'in_progress').length} ì§„í–‰ì¤‘, ${incompleteTodos.filter(t => t.status === 'pending').length} ëŒ€ê¸°ì¤‘]`;
    
    let prompt = `## ğŸ”„ Mission Loop - Iteration ${this.state!.iteration}

${intervention ? `âš ï¸ **INTERVENTION**: ${intervention}\n\n` : ''}

### Current Progress ${progress}
${incompleteTodos.map(t => `- [${t.status === 'in_progress' ? '~' : ' '}] ${t.content} (${t.priority})`).join('\n')}

**Continue executing the next pending task.**
**Update todo status using todowrite as you progress.**`;

    return prompt;
  }

  /**
   * ìŠ¤í…Œê·¸ë„¤ì´ì…˜ ê°œì… í”„ë¡¬í”„íŠ¸
   */
  private buildStagnationIntervention(incompleteTodos: Todo[]): string {
    return `No progress detected for ${this.state!.stagnationCount} iterations.

**Action Required:**
1. If stuck on a task, mark it as 'cancelled' and explain why
2. If blocked by external factors, document them
3. If the approach is wrong, revise the TODO list
4. Consider breaking down complex tasks

Do NOT repeat the same actions without changes.`;
  }

  /**
   * ê°•ì œ ì¬í‰ê°€ í”„ë¡¬í”„íŠ¸
   */
  private buildForceReassessPrompt(incompleteTodos: Todo[]): string {
    return `â›” **CRITICAL: Prolonged stagnation detected**

You have been stuck for ${this.state!.stagnationCount} iterations.

**You MUST do one of the following:**
1. Complete at least one todo OR
2. Cancel impossible todos with explanation OR  
3. Request user intervention with specific questions

If you cannot proceed, output: "MISSION_BLOCKED: [reason]"`;
  }

  private hashTodos(todos: Todo[]): string {
    return todos.map(t => `${t.id}:${t.status}`).sort().join('|');
  }

  private saveState(): void {
    // ìƒíƒœë¥¼ íŒŒì¼ì— ì €ì¥ (ê¸°ì¡´ mission-loop.json í™œìš©)
    const filePath = join(this.directory, '.opencode', 'mission-loop.json');
    writeFileSync(filePath, JSON.stringify(this.state, null, 2));
  }
}
```

### 4.3 í†µí•©: ê¸°ì¡´ mission-loop ìˆ˜ì •

```typescript
// src/core/loop/mission-loop-handler.ts ìˆ˜ì •

// ê¸°ì¡´ handleMissionIdle í•¨ìˆ˜ ìˆ˜ì •
export async function handleMissionIdle(client, directory, sessionID, mainSessionID) {
  // ... ê¸°ì¡´ ì²´í¬ ë¡œì§ ...

  // â­ ë¬´í•œ ë£¨í”„ ì»¨íŠ¸ë¡¤ëŸ¬ ì‚¬ìš©
  const controller = InfiniteLoopController.getInstance(client, directory);
  const result = await controller.checkContinuation();

  if (!result.continue) {
    // ì™„ë£Œ ë˜ëŠ” ì¤‘ë‹¨
    await handleMissionComplete(client, directory, loopState);
    return;
  }

  // Continuation í”„ë¡¬í”„íŠ¸ ì£¼ì…
  await client.session.prompt({
    path: { id: sessionID },
    body: { parts: [{ type: 'text', text: result.prompt }] },
  });
}
```

---

## 5. ë³‘ë ¬ ì²˜ë¦¬ ê°•í™”

### 5.1 í˜„ì¬ ì œí•œ ì‚¬í•­

```typescript
// session-pool.ts í˜„ì¬ ì„¤ì •
const DEFAULT_CONFIG = {
  maxPoolSizePerAgent: 5,  // âŒ ì—ì´ì „íŠ¸ë‹¹ 5ê°œë¡œ ì œí•œ
};

// concurrency.ts í˜„ì¬ ì„¤ì •
// ì—ì´ì „íŠ¸ë³„ ê³ ì • ì œí•œ
```

### 5.2 ê°œì„ ì•ˆ: AdaptiveConcurrencyController

```typescript
// src/core/agents/adaptive-concurrency.ts (ì‹ ê·œ, ~150ì¤„)

export interface AdaptiveConcurrencyConfig {
  /** ì „ì—­ ìµœëŒ€ ë™ì‹œ ì‘ì—… ìˆ˜ */
  globalMax: number;
  
  /** ì—ì´ì „íŠ¸ë³„ ìµœì†Œ ìŠ¬ë¡¯ */
  perAgentMin: number;
  
  /** ì—ì´ì „íŠ¸ë³„ ìµœëŒ€ ìŠ¬ë¡¯ */
  perAgentMax: number;
  
  /** ìŠ¤ì¼€ì¼ì—… ì„ê³„ê°’ (ì„±ê³µë¥ ) */
  scaleUpThreshold: number;
  
  /** ìŠ¤ì¼€ì¼ë‹¤ìš´ ì„ê³„ê°’ (ì‹¤íŒ¨ìœ¨) */
  scaleDownThreshold: number;
  
  /** ì¡°ì • ì£¼ê¸° (ms) */
  adjustmentInterval: number;
}

const DEFAULT_ADAPTIVE_CONFIG: AdaptiveConcurrencyConfig = {
  globalMax: 20,              // â­ ì „ì—­ ìµœëŒ€ 20ê°œ
  perAgentMin: 2,
  perAgentMax: 10,            // â­ ì—ì´ì „íŠ¸ë³„ ìµœëŒ€ 10ê°œ
  scaleUpThreshold: 0.9,      // 90% ì„±ê³µ ì‹œ ìŠ¤ì¼€ì¼ì—…
  scaleDownThreshold: 0.5,    // 50% ë¯¸ë§Œ ì„±ê³µ ì‹œ ìŠ¤ì¼€ì¼ë‹¤ìš´
  adjustmentInterval: 60000,  // 1ë¶„ë§ˆë‹¤ ì¡°ì •
};

export class AdaptiveConcurrencyController {
  private config: AdaptiveConcurrencyConfig;
  private currentLimits: Map<string, number> = new Map();
  private metrics: Map<string, { success: number; failure: number; latency: number[] }> = new Map();
  private adjustmentTimer: NodeJS.Timeout | null = null;

  constructor(config?: Partial<AdaptiveConcurrencyConfig>) {
    this.config = { ...DEFAULT_ADAPTIVE_CONFIG, ...config };
    this.startAdjustmentCycle();
  }

  /**
   * ë™ì ìœ¼ë¡œ ìŠ¬ë¡¯ í• ë‹¹
   */
  getLimit(agent: string): number {
    if (!this.currentLimits.has(agent)) {
      this.currentLimits.set(agent, this.config.perAgentMin);
    }
    return this.currentLimits.get(agent)!;
  }

  /**
   * ì‘ì—… ê²°ê³¼ ë³´ê³  (ì ì‘í˜• ì¡°ì ˆìš©)
   */
  reportResult(agent: string, success: boolean, latencyMs: number): void {
    let m = this.metrics.get(agent);
    if (!m) {
      m = { success: 0, failure: 0, latency: [] };
      this.metrics.set(agent, m);
    }
    if (success) m.success++;
    else m.failure++;
    m.latency.push(latencyMs);
    
    // íˆìŠ¤í† ë¦¬ ì œí•œ (ìµœê·¼ 100ê°œ)
    if (m.latency.length > 100) m.latency.shift();
  }

  /**
   * í˜„ì¬ ì „ì—­ ì‚¬ìš©ëŸ‰
   */
  getTotalInUse(): number {
    // Storeë‚˜ Poolì—ì„œ ê°€ì ¸ì™€ì•¼ í•¨
    return 0; // êµ¬í˜„ í•„ìš”
  }

  /**
   * ì£¼ê¸°ì ìœ¼ë¡œ ì œí•œ ì¡°ì •
   */
  private startAdjustmentCycle(): void {
    this.adjustmentTimer = setInterval(() => {
      this.adjustLimits();
    }, this.config.adjustmentInterval);
    this.adjustmentTimer.unref?.();
  }

  private adjustLimits(): void {
    for (const [agent, metrics] of this.metrics) {
      const total = metrics.success + metrics.failure;
      if (total < 10) continue; // ìƒ˜í”Œ ë¶€ì¡±

      const successRate = metrics.success / total;
      const currentLimit = this.getLimit(agent);

      if (successRate >= this.config.scaleUpThreshold && currentLimit < this.config.perAgentMax) {
        // ìŠ¤ì¼€ì¼ì—…
        this.currentLimits.set(agent, currentLimit + 1);
        log(`[AdaptiveConcurrency] ${agent}: ${currentLimit} â†’ ${currentLimit + 1} (success rate: ${(successRate * 100).toFixed(1)}%)`);
      } else if (successRate < this.config.scaleDownThreshold && currentLimit > this.config.perAgentMin) {
        // ìŠ¤ì¼€ì¼ë‹¤ìš´
        this.currentLimits.set(agent, currentLimit - 1);
        log(`[AdaptiveConcurrency] ${agent}: ${currentLimit} â†’ ${currentLimit - 1} (success rate: ${(successRate * 100).toFixed(1)}%)`);
      }

      // ë©”íŠ¸ë¦­ ë¦¬ì…‹
      this.metrics.set(agent, { success: 0, failure: 0, latency: [] });
    }
  }

  cleanup(): void {
    if (this.adjustmentTimer) {
      clearInterval(this.adjustmentTimer);
      this.adjustmentTimer = null;
    }
  }
}
```

### 5.3 SessionPool ê°•í™”

```typescript
// src/core/agents/session-pool.ts ìˆ˜ì •

const ENHANCED_CONFIG: SessionPoolConfig = {
  maxPoolSizePerAgent: 10,    // â­ 5 â†’ 10
  idleTimeoutMs: 180_000,     // 3ë¶„ (5ë¶„ì—ì„œ ë‹¨ì¶•)
  maxReuseCount: 20,          // â­ 10 â†’ 20
  globalMax: 30,              // â­ ì „ì—­ ìµœëŒ€ 30ê°œ ì„¸ì…˜
  healthCheckIntervalMs: 30_000, // 30ì´ˆë§ˆë‹¤ í—¬ìŠ¤ì²´í¬
};

// ì¶”ê°€ ë©”ì„œë“œ
export class SessionPool {
  // ... ê¸°ì¡´ ì½”ë“œ ...

  /**
   * ì¦‰ì‹œ ì„¸ì…˜ ìƒì„± (í’€ì—ì„œ ì—†ìœ¼ë©´ ìƒì„±)
   */
  async acquireImmediate(agentName: string, parentSessionID: string, description: string): Promise<PooledSession> {
    // í’€ì—ì„œ ë¨¼ì € ì‹œë„
    const pooled = await this.acquireFromPool(agentName);
    if (pooled) return pooled;

    // ì „ì—­ ì œí•œ ì²´í¬
    const totalActive = this.sessionsById.size;
    if (totalActive >= this.config.globalMax) {
      throw new Error(`Global session limit (${this.config.globalMax}) reached`);
    }

    // ìƒˆë¡œ ìƒì„±
    return this.createSession(agentName, parentSessionID, description);
  }

  /**
   * ê°•ì œ íšŒìˆ˜ (íƒ€ì„ì•„ì›ƒëœ ì„¸ì…˜)
   */
  async forceReclaim(count: number): Promise<number> {
    const now = Date.now();
    const candidates = Array.from(this.sessionsById.values())
      .filter(s => !s.inUse)
      .sort((a, b) => a.lastUsedAt.getTime() - b.lastUsedAt.getTime())
      .slice(0, count);

    for (const session of candidates) {
      await this.deleteSession(session.id);
    }

    return candidates.length;
  }
}
```

---

## 6. ì•ˆì „í•œ ë¦¬ì†ŒìŠ¤ íšŒìˆ˜

### 6.1 í˜„ì¬ ë¬¸ì œ: ë¶„ì‚°ëœ Cleanup

```
í˜„ì¬ cleanup í•¨ìˆ˜ ë¶„í¬:
â”œâ”€â”€ todo-continuation.ts     â†’ cleanupSession()
â”œâ”€â”€ mission-loop-handler.ts  â†’ cleanupSession()
â”œâ”€â”€ continuation-lock.ts     â†’ cleanupContinuationLock()
â”œâ”€â”€ session-health.ts        â†’ cleanupSessionHealth()
â”œâ”€â”€ unified-task-executor.ts â†’ cleanup()
â”œâ”€â”€ session-pool.ts          â†’ cleanup(), shutdown()
â”œâ”€â”€ manager.ts               â†’ cleanup()
â””â”€â”€ cleanup-scheduler.ts     â†’ compactWAL(), cleanDocs(), rotateHistory()
```

### 6.2 ê°œì„ ì•ˆ: ResourceTracker (ì¤‘ì•™í™”)

```typescript
// src/core/resource/resource-tracker.ts (ì‹ ê·œ, ~250ì¤„)

export enum ResourceType {
  SESSION = 'session',
  TIMER = 'timer',
  INTERVAL = 'interval',
  FILE_HANDLE = 'file_handle',
  MEMORY = 'memory',
}

interface TrackedResource {
  id: string;
  type: ResourceType;
  sessionID?: string;
  createdAt: number;
  metadata?: Record<string, unknown>;
  cleanup: () => Promise<void> | void;
}

export class ResourceTracker {
  private static _instance: ResourceTracker;
  private resources: Map<string, TrackedResource> = new Map();
  private sessionResources: Map<string, Set<string>> = new Map();

  private constructor() {}

  static getInstance(): ResourceTracker {
    if (!ResourceTracker._instance) {
      ResourceTracker._instance = new ResourceTracker();
    }
    return ResourceTracker._instance;
  }

  /**
   * ë¦¬ì†ŒìŠ¤ ë“±ë¡
   */
  track(resource: TrackedResource): void {
    this.resources.set(resource.id, resource);
    
    if (resource.sessionID) {
      let set = this.sessionResources.get(resource.sessionID);
      if (!set) {
        set = new Set();
        this.sessionResources.set(resource.sessionID, set);
      }
      set.add(resource.id);
    }

    log(`[ResourceTracker] Tracked: ${resource.type}:${resource.id}` + 
        (resource.sessionID ? ` (session: ${resource.sessionID.slice(0, 8)})` : ''));
  }

  /**
   * ë¦¬ì†ŒìŠ¤ í•´ì œ
   */
  async release(id: string): Promise<boolean> {
    const resource = this.resources.get(id);
    if (!resource) return false;

    try {
      await resource.cleanup();
    } catch (err) {
      log(`[ResourceTracker] Cleanup error for ${id}: ${err}`);
    }

    this.resources.delete(id);
    
    if (resource.sessionID) {
      const set = this.sessionResources.get(resource.sessionID);
      set?.delete(id);
      if (set?.size === 0) {
        this.sessionResources.delete(resource.sessionID);
      }
    }

    log(`[ResourceTracker] Released: ${resource.type}:${id}`);
    return true;
  }

  /**
   * ì„¸ì…˜ì˜ ëª¨ë“  ë¦¬ì†ŒìŠ¤ í•´ì œ (í•µì‹¬!)
   */
  async releaseAllForSession(sessionID: string): Promise<number> {
    const resourceIds = this.sessionResources.get(sessionID);
    if (!resourceIds || resourceIds.size === 0) return 0;

    let released = 0;
    const ids = Array.from(resourceIds); // ë³µì‚¬ (ìˆœíšŒ ì¤‘ ì‚­ì œ ë°©ì§€)

    for (const id of ids) {
      if (await this.release(id)) {
        released++;
      }
    }

    log(`[ResourceTracker] Released ${released} resources for session ${sessionID.slice(0, 8)}`);
    return released;
  }

  /**
   * íƒ€ì…ë³„ ë¦¬ì†ŒìŠ¤ í•´ì œ
   */
  async releaseByType(type: ResourceType): Promise<number> {
    let released = 0;
    for (const [id, resource] of this.resources) {
      if (resource.type === type) {
        if (await this.release(id)) {
          released++;
        }
      }
    }
    return released;
  }

  /**
   * ì˜¤ë˜ëœ ë¦¬ì†ŒìŠ¤ ì •ë¦¬ (GC)
   */
  async cleanupStale(maxAgeMs: number): Promise<number> {
    const now = Date.now();
    let cleaned = 0;

    for (const [id, resource] of this.resources) {
      if (now - resource.createdAt > maxAgeMs) {
        if (await this.release(id)) {
          cleaned++;
        }
      }
    }

    return cleaned;
  }

  /**
   * ì „ì²´ ì •ë¦¬ (ì…§ë‹¤ìš´ ì‹œ)
   */
  async shutdown(): Promise<void> {
    log(`[ResourceTracker] Shutting down, releasing ${this.resources.size} resources...`);
    
    const allIds = Array.from(this.resources.keys());
    await Promise.allSettled(allIds.map(id => this.release(id)));
    
    this.resources.clear();
    this.sessionResources.clear();
    
    log('[ResourceTracker] Shutdown complete');
  }

  /**
   * í†µê³„
   */
  getStats(): { total: number; byType: Record<ResourceType, number>; bySessions: number } {
    const byType = {} as Record<ResourceType, number>;
    for (const type of Object.values(ResourceType)) {
      byType[type] = 0;
    }
    for (const resource of this.resources.values()) {
      byType[resource.type]++;
    }
    return {
      total: this.resources.size,
      byType,
      bySessions: this.sessionResources.size,
    };
  }
}

// í—¬í¼ í•¨ìˆ˜ë“¤
export function trackTimer(timer: NodeJS.Timeout, sessionID?: string): string {
  const id = `timer_${Date.now()}_${Math.random().toString(36).slice(2)}`;
  ResourceTracker.getInstance().track({
    id,
    type: ResourceType.TIMER,
    sessionID,
    createdAt: Date.now(),
    cleanup: () => clearTimeout(timer),
  });
  return id;
}

export function trackInterval(interval: NodeJS.Timeout, sessionID?: string): string {
  const id = `interval_${Date.now()}_${Math.random().toString(36).slice(2)}`;
  ResourceTracker.getInstance().track({
    id,
    type: ResourceType.INTERVAL,
    sessionID,
    createdAt: Date.now(),
    cleanup: () => clearInterval(interval),
  });
  return id;
}

export function trackSession(sessionID: string, cleanupFn: () => Promise<void>): void {
  ResourceTracker.getInstance().track({
    id: `session_${sessionID}`,
    type: ResourceType.SESSION,
    sessionID,
    createdAt: Date.now(),
    cleanup: cleanupFn,
  });
}
```

### 6.3 í†µí•©: ê¸°ì¡´ ì½”ë“œ ìˆ˜ì •

```typescript
// src/plugin-handlers/event-handler.ts ìˆ˜ì •

import { ResourceTracker } from '../core/resource/resource-tracker.js';

// session.deleted ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
if (eventType === 'session.deleted') {
  const sessionID = event.properties.info.id;
  
  // â­ ì¤‘ì•™í™”ëœ ë¦¬ì†ŒìŠ¤ í•´ì œ
  const tracker = ResourceTracker.getInstance();
  const released = await tracker.releaseAllForSession(sessionID);
  log(`[EventHandler] Session ${sessionID.slice(0, 8)} deleted, ${released} resources released`);
}

// src/core/agents/unified-task-executor.ts ìˆ˜ì •

import { trackTimer, ResourceTracker } from '../resource/resource-tracker.js';

// íƒ€ì´ë¨¸ ìƒì„± ì‹œ
private scheduleCleanup(taskId: string): void {
  const timer = setTimeout(() => { ... }, PARALLEL_TASK.CLEANUP_DELAY_MS);
  
  // â­ ResourceTrackerì— ë“±ë¡
  trackTimer(timer, task.sessionID);
  this.cleanupTimers.set(taskId, timer);
}
```

---

## 7. êµ¬í˜„ ê³„íš

### 7.1 íŒŒì¼ êµ¬ì¡° ë³€ê²½

```
src/core/
â”œâ”€â”€ loop/
â”‚   â”œâ”€â”€ mission-loop.ts              # ê¸°ì¡´ (ìˆ˜ì •)
â”‚   â”œâ”€â”€ mission-loop-handler.ts      # ê¸°ì¡´ (ìˆ˜ì •)
â”‚   â”œâ”€â”€ infinite-loop-controller.ts  # â­ ì‹ ê·œ
â”‚   â””â”€â”€ ...
â”œâ”€â”€ agents/
â”‚   â”œâ”€â”€ session-pool.ts              # ê¸°ì¡´ (ìˆ˜ì •)
â”‚   â”œâ”€â”€ adaptive-concurrency.ts      # â­ ì‹ ê·œ
â”‚   â””â”€â”€ ...
â”œâ”€â”€ resource/
â”‚   â””â”€â”€ resource-tracker.ts          # â­ ì‹ ê·œ
â””â”€â”€ ...
```

### 7.2 êµ¬í˜„ ìˆœì„œ

```
Phase 1: ë¬´í•œ ë£¨í”„ ë³´ì¥ (2ì¼)
â”œâ”€â”€ InfiniteLoopController êµ¬í˜„
â”œâ”€â”€ mission-loop-handler ìˆ˜ì •
â””â”€â”€ í…ŒìŠ¤íŠ¸

Phase 2: ë³‘ë ¬ ê°•í™” (1.5ì¼)
â”œâ”€â”€ AdaptiveConcurrencyController êµ¬í˜„
â”œâ”€â”€ SessionPool ìˆ˜ì •
â””â”€â”€ í…ŒìŠ¤íŠ¸

Phase 3: ì•ˆì „í•œ ë¦¬ì†ŒìŠ¤ íšŒìˆ˜ (1.5ì¼)
â”œâ”€â”€ ResourceTracker êµ¬í˜„
â”œâ”€â”€ ê¸°ì¡´ cleanup ì½”ë“œ í†µí•©
â””â”€â”€ í…ŒìŠ¤íŠ¸

Phase 4: í†µí•© í…ŒìŠ¤íŠ¸ (1ì¼)
â”œâ”€â”€ E2E í…ŒìŠ¤íŠ¸
â”œâ”€â”€ ìŠ¤íŠ¸ë ˆìŠ¤ í…ŒìŠ¤íŠ¸
â””â”€â”€ ë¬¸ì„œí™”
```

**ì´ ì†Œìš”: 6ì¼**

### 7.3 ì½”ë“œëŸ‰ ë³€í™”

| í•­ëª© | ë³€í™” |
|------|------|
| ì‹ ê·œ íŒŒì¼ | +3ê°œ (~600ì¤„) |
| ìˆ˜ì • íŒŒì¼ | 5ê°œ |
| ì‚­ì œ ì½”ë“œ (ì¤‘ë³µ cleanup) | -200ì¤„ |
| **ìˆœ ì¦ê°€** | **+400ì¤„** |

---

## 8. ìš”ì•½

| ê°œì„  í•­ëª© | í˜„ì¬ | ê°œì„  í›„ |
|----------|------|---------|
| **ë¯¸ì…˜ ë£¨í”„** | maxIterations=100 | `infinite=true` (Todo ì™„ë£Œê¹Œì§€) |
| **ë³‘ë ¬ ì²˜ë¦¬** | ì—ì´ì „íŠ¸ë‹¹ 5ê°œ | ìµœëŒ€ 20ê°œ (ë™ì  ì¡°ì ˆ) |
| **ë¦¬ì†ŒìŠ¤ íšŒìˆ˜** | ë¶„ì‚° cleanup | ResourceTracker ì¤‘ì•™í™” |
| **ìŠ¤í…Œê·¸ë„¤ì´ì…˜** | ë‹¨ìˆœ ê°ì§€ | ì ì‘í˜• ê°œì… + ê°•ì œ ì¬í‰ê°€ |

### í•µì‹¬ ë³´ì¥

1. âœ… `/task` ì‹¤í–‰ ì‹œ **ëª¨ë“  Todoê°€ ì™„ë£Œë  ë•Œê¹Œì§€ ë¬´í•œ ë°˜ë³µ**
2. âœ… ìŠ¤í…Œê·¸ë„¤ì´ì…˜ ê°ì§€ ì‹œ **ìë™ ê°œì…** (ë¬´í•œ ë£¨í”„ ë°©ì§€ì˜ ë°©ì§€)
3. âœ… ë³‘ë ¬ ì‘ì—… **ìµœëŒ€ 20ê°œ ë™ì‹œ ì‹¤í–‰**
4. âœ… ì„¸ì…˜ ì¢…ë£Œ ì‹œ **ëª¨ë“  ë¦¬ì†ŒìŠ¤ 100% íšŒìˆ˜ ë³´ì¥**
