# OpenCode Orchestrator 전면 재설계안

> **작성일**: 2026-01-27
> **현재 버전**: 1.2.21
> **목표**: OpenCode 네이티브 API 활용, 중복 인프라 제거

---

## 1. 근본 문제 진단

### 1.1 현재 구조의 핵심 오류

**OpenCode는 이미 다음을 제공함:**
```typescript
// OpenCode 내장 Todo 시스템 (/packages/opencode/src/session/todo.ts)
export namespace Todo {
  export const Info = z.object({
    content: z.string().describe("Brief description of the task"),
    status: z.string().describe("Current status: pending, in_progress, completed, cancelled"),
    priority: z.string().describe("Priority level: high, medium, low"),
    id: z.string().describe("Unique identifier for the todo item"),
  })

  // Storage API로 자동 저장 + TUI 자동 업데이트
  export async function update(input: { sessionID: string; todos: Info[] }) {
    await Storage.write(["todo", input.sessionID], input.todos)
    Bus.publish(Event.Updated, input)  // TUI 자동 업데이트
  }

  export async function get(sessionID: string) {
    return Storage.read<Info[]>(["todo", sessionID])
  }
}
```

**현재 Orchestrator가 하는 일:**
```
❌ 자체 TODO 파일 관리 (todo.md + MVCC)
❌ 자체 상태 파일 관리 (mission-loop.json 등)
❌ 자체 TUI 통합 (TaskToastManager)
❌ 파일 기반 세션 관리 (.opencode/*.md)
```

**문제:** OpenCode의 기능을 무시하고 병렬 인프라를 구축함

---

## 2. OpenCode 실제 API 분석

### 2.1 SDK API (플러그인에서 사용 가능)

```typescript
// @opencode-ai/sdk - 실제 사용 가능한 API
const client = createOpencodeClient({ baseUrl: "http://localhost:4096" })

// 세션 관리
await client.session.create()                           // 세션 생성
await client.session.get({ sessionID })                 // 세션 조회
await client.session.status({ sessionID })              // 세션 상태 (idle/busy)
await client.session.delete({ sessionID })              // 세션 삭제
await client.session.children({ sessionID })            // 자식 세션 목록

// 메시지/프롬프트
await client.session.prompt({                           // 메시지 전송 (스트리밍)
  sessionID,
  parts: [{ type: "text", text: "Hello" }],
  agent: "build",                                       // 에이전트 지정
  model: { providerID: "anthropic", modelID: "claude-sonnet-4-20250514" }
})
await client.session.messages({ sessionID })            // 메시지 목록 조회

// Todo (읽기 전용)
await client.session.todo({ sessionID })                // Todo 목록 조회

// 이벤트 구독
await client.global.event()                             // SSE 이벤트 스트림
```

### 2.2 플러그인 훅 시스템 (실제 존재)

```typescript
// @opencode-ai/plugin - Hooks 인터페이스
export interface Hooks {
  // 이벤트 구독
  event?: (input: { event: Event }) => Promise<void>
  
  // 설정
  config?: (input: Config) => Promise<void>
  
  // 커스텀 도구 정의
  tool?: { [key: string]: ToolDefinition }
  
  // 메시지 수신 시
  "chat.message"?: (
    input: { sessionID, agent?, model?, messageID?, variant? },
    output: { message: UserMessage; parts: Part[] }
  ) => Promise<void>
  
  // LLM 파라미터 수정
  "chat.params"?: (input, output: { temperature, topP, topK, options }) => Promise<void>
  
  // 도구 실행 전
  "tool.execute.before"?: (
    input: { tool, sessionID, callID },
    output: { args: any }
  ) => Promise<void>
  
  // 도구 실행 후
  "tool.execute.after"?: (
    input: { tool, sessionID, callID },
    output: { title, output, metadata }
  ) => Promise<void>
  
  // 권한 요청 시
  "permission.ask"?: (input: Permission, output: { status }) => Promise<void>
  
  // 시스템 프롬프트 변환 (실험적)
  "experimental.chat.system.transform"?: (
    input: { sessionID?, model },
    output: { system: string[] }
  ) => Promise<void>
}
```

### 2.3 Todo 업데이트 방식

**중요:** Todo는 `TodoWriteTool`을 통해서만 업데이트 가능

```typescript
// OpenCode 내부: src/tool/todo.ts
export const TodoWriteTool = Tool.define("todowrite", {
  description: DESCRIPTION_WRITE,
  parameters: z.object({
    todos: z.array(z.object(Todo.Info.shape))
  }),
  async execute(params, ctx) {
    await Todo.update({
      sessionID: ctx.sessionID,
      todos: params.todos,
    })
    return { title: `${params.todos.filter(x => x.status !== "completed").length} todos` }
  },
})
```

**결론:** 플러그인에서 Todo를 직접 업데이트할 수 없음. LLM이 `todowrite` 도구를 호출해야 함.

---

## 3. 핵심 결정

### 결정 1: OpenCode 네이티브 API 활용 범위

| 기능 | 현재 (삭제) | 변경 (OpenCode API) |
|------|-------------|---------------------|
| TODO 관리 | `todo.md` + MVCC | `client.session.todo()` (읽기) + LLM todowrite |
| 세션 관리 | 자체 구현 | `client.session.*` API |
| 메시지 전송 | 직접 처리 | `client.session.prompt()` |
| 이벤트 구독 | 폴링 | `Hooks.event` + `client.global.event()` |
| 상태 저장 | `.opencode/*.json` | 세션 메타데이터 또는 최소 파일 |

### 결정 2: 제거 대상

**완전 삭제 (불필요한 중복):**
```
src/core/todo/                    # 전체 삭제 (599줄)
  ├── todo-manager.ts             # OpenCode Todo API로 대체
  ├── todo-sync-service.ts        # 불필요
  └── task-wal.ts                 # 불필요 (MVCC 제거)

src/core/tui/task-toast-manager.ts # 삭제 (OpenCode 이벤트 사용)
```

**단순화 대상:**
```
src/core/loop/                    # 단순화 (1,735줄 → ~400줄)
  ├── mission-loop.ts             # MissionController로 통합
  ├── mission-loop-handler.ts     # MissionController로 통합
  ├── todo-continuation.ts        # 단순화
  └── verification.ts             # 간소화
```

**삭제 대상 .opencode 파일:**
```
.opencode/todo.md                 # OpenCode 내장 Todo 사용
.opencode/todo.version.json       # MVCC 제거
.opencode/status.md               # 삭제
.opencode/sync-issues.md          # 삭제
.opencode/archive/todo_history.jsonl # 삭제
.opencode/archive/tasks/active_tasks.jsonl # 삭제
```

### 결정 3: 유지 대상

```
src/core/agents/                  # 유지 (단순화)
src/tools/                        # 유지
src/agents/                       # 유지 (프롬프트)
src/hooks/                        # 유지 (SDK 훅과 연동)
crates/                           # 유지 (Rust 도구)
```

---

## 4. 신규 아키텍처

### 4.1 구조도

```
┌──────────────────────────────────────────────────────────────┐
│                     OpenCode (Host)                          │
├──────────────────────────────────────────────────────────────┤
│  SDK API         │  Todo API     │  Event Bus   │  Hooks    │
│  (HTTP/REST)     │  (읽기 전용)   │  (SSE)       │  (Plugin) │
└───────┬──────────┴───────┬───────┴───────┬──────┴─────┬─────┘
        │                  │               │            │
        ▼                  ▼               ▼            ▼
┌──────────────────────────────────────────────────────────────┐
│                   Orchestrator Plugin                        │
├──────────────────────────────────────────────────────────────┤
│  MissionController (~250줄)                                  │
│  ├── start(prompt) → session.create() + prompt()            │
│  ├── getTodos() → session.todo()                            │
│  ├── checkComplete() → todo 상태 확인                        │
│  └── nextIteration() → continuation prompt 생성              │
├──────────────────────────────────────────────────────────────┤
│  HookIntegration                                             │
│  ├── chat.message → 미션 모드 감지                           │
│  ├── tool.execute.after → 진행 상황 모니터링                 │
│  └── event → 세션 이벤트 구독                                │
├──────────────────────────────────────────────────────────────┤
│  AgentExecutor (유지, 단순화)                                │
│  ├── SessionPool → client.session.*                         │
│  └── TaskRunner                                              │
├──────────────────────────────────────────────────────────────┤
│  Rust Tools (유지)                                           │
│  └── grep, glob, sed, diff, ast, lsp...                     │
└──────────────────────────────────────────────────────────────┘
```

### 4.2 MissionController (신규, ~250줄)

```typescript
// src/core/mission/mission-controller.ts

import type { PluginInput } from '@opencode-ai/plugin';
import type { Todo } from '@opencode-ai/sdk';

interface MissionState {
  id: string;
  sessionID: string;
  prompt: string;
  status: 'active' | 'completed' | 'failed';
  iteration: number;
  maxIterations: number;
  startedAt: string;
}

export class MissionController {
  private state: MissionState | null = null;
  private client: PluginInput['client'];

  constructor(input: PluginInput) {
    this.client = input.client;
  }

  // 미션 시작: 새 세션 생성 및 Commander 프롬프트 전송
  async start(prompt: string): Promise<string> {
    // 새 세션 생성
    const session = await this.client.session.create({});

    this.state = {
      id: crypto.randomUUID(),
      sessionID: session.id,
      prompt,
      status: 'active',
      iteration: 1,
      maxIterations: 50,
      startedAt: new Date().toISOString(),
    };

    // Commander 프롬프트 전송
    await this.client.session.prompt({
      sessionID: session.id,
      parts: [{ type: 'text', text: this.buildCommanderPrompt(prompt) }],
      agent: 'build',
    });

    return session.id;
  }

  // Todo 목록 조회 (OpenCode 내장 API 사용)
  async getTodos(): Promise<Todo[]> {
    if (!this.state) return [];
    return this.client.session.todo({ sessionID: this.state.sessionID });
  }

  // 완료 여부 확인
  async checkComplete(): Promise<boolean> {
    const todos = await this.getTodos();
    if (todos.length === 0) return false;
    return todos.every(t => t.status === 'completed');
  }

  // 다음 반복 실행
  async nextIteration(): Promise<{ continue: boolean; prompt?: string }> {
    if (!this.state) return { continue: false };

    // 세션 상태 확인
    const status = await this.client.session.status({ 
      sessionID: this.state.sessionID 
    });
    if (status.status === 'busy') {
      // 아직 실행 중이면 대기
      return { continue: true };
    }

    const isComplete = await this.checkComplete();

    if (isComplete) {
      this.state.status = 'completed';
      return { continue: false };
    }

    if (this.state.iteration >= this.state.maxIterations) {
      this.state.status = 'failed';
      return { continue: false };
    }

    this.state.iteration++;

    const todos = await this.getTodos();
    const pending = todos.filter(t => t.status !== 'completed');
    const prompt = this.buildContinuationPrompt(pending);

    // 다음 메시지 전송
    await this.client.session.prompt({
      sessionID: this.state.sessionID,
      parts: [{ type: 'text', text: prompt }],
    });

    return { continue: true, prompt };
  }

  private buildCommanderPrompt(prompt: string): string {
    return `## Mission Mode Activated

**Objective:** ${prompt}

You are the Commander agent. Your responsibilities:
1. Analyze the task and create a TODO list using the todowrite tool
2. Execute tasks systematically, updating todo status as you progress
3. Verify completion before finishing

Start by creating a detailed TODO list for this mission.`;
  }

  private buildContinuationPrompt(pending: Todo[]): string {
    return `## Continue Mission (Iteration ${this.state!.iteration}/${this.state!.maxIterations})

### Remaining Tasks:
${pending.map(t => `- [${t.status === 'in_progress' ? '~' : ' '}] ${t.content} (${t.priority})`).join('\n')}

Continue working on the next pending task. Update todo status as you make progress.`;
  }

  getState(): MissionState | null {
    return this.state;
  }

  reset(): void {
    this.state = null;
  }
}
```

### 4.3 플러그인 진입점 (단순화)

```typescript
// src/index.ts (기존 ~226줄 → ~150줄)

import type { Plugin, Hooks } from '@opencode-ai/plugin';
import { MissionController } from './core/mission/mission-controller';
import { tools } from './tools';

export const OrchestratorPlugin: Plugin = async (input) => {
  const { client } = input;
  let mission: MissionController | null = null;
  let missionActive = false;

  const hooks: Hooks = {
    // 커스텀 도구 등록
    tool: tools(input),

    // 메시지 수신 시: /task 명령어 감지
    "chat.message": async (ctx, output) => {
      const message = output.message;
      if (!message?.parts) return;

      const textPart = message.parts.find(p => p.type === 'text');
      if (!textPart) return;

      const text = textPart.text;
      const match = text.match(/^\/task\s+"(.+)"$/);
      
      if (match) {
        const prompt = match[1];
        mission = new MissionController(input);
        missionActive = true;
        
        // 미션 시작
        await mission.start(prompt);
        
        // 원본 메시지를 Commander 프롬프트로 변환
        textPart.text = mission['buildCommanderPrompt'](prompt);
      }
    },

    // 도구 실행 후: 진행 상황 모니터링
    "tool.execute.after": async (ctx, output) => {
      if (!missionActive || !mission) return;

      // todowrite 도구 호출 후 Todo 상태 확인
      if (ctx.tool === 'todowrite') {
        const isComplete = await mission.checkComplete();
        if (isComplete) {
          missionActive = false;
          console.log('[Orchestrator] Mission completed!');
        }
      }
    },

    // 이벤트 구독
    event: async ({ event }) => {
      // 세션 삭제 이벤트
      if (event.type === 'session.deleted') {
        if (mission?.getState()?.sessionID === event.properties.info.id) {
          mission.reset();
          missionActive = false;
        }
      }

      // 세션 idle 상태 → 다음 반복 체크
      if (event.type === 'session.status' && missionActive && mission) {
        const state = mission.getState();
        if (state && event.properties.sessionID === state.sessionID) {
          if (event.properties.status === 'idle') {
            const result = await mission.nextIteration();
            if (!result.continue) {
              missionActive = false;
              console.log(`[Orchestrator] Mission ${state.status}`);
            }
          }
        }
      }
    },
  };

  return hooks;
};

export default OrchestratorPlugin;
```

---

## 5. 훅 시스템 정리

### 현재 vs 변경

**현재 (200줄, 과도한 복잡성):**
- 위상 정렬 알고리즘
- 순환 의존성 감지
- Phase + Priority + Dependencies

**변경 (OpenCode 네이티브 훅 활용):**

```typescript
// src/hooks/integration.ts (~60줄)

import type { Hooks, PluginInput } from '@opencode-ai/plugin';

export function createHookIntegration(input: PluginInput): Partial<Hooks> {
  return {
    // 도구 실행 전 검증
    "tool.execute.before": async (ctx, output) => {
      // 위험한 명령어 차단 등
      if (ctx.tool === 'bash') {
        const command = output.args?.command || '';
        if (isDangerousCommand(command)) {
          throw new Error('Dangerous command blocked');
        }
      }
    },

    // 도구 실행 후 로깅
    "tool.execute.after": async (ctx, output) => {
      console.log(`[Hook] Tool executed: ${ctx.tool}`);
    },

    // 권한 자동 승인 (선택적)
    "permission.ask": async (input, output) => {
      // 자동 승인할 패턴 정의
      if (input.permission === 'read' && input.patterns?.every(p => p.endsWith('.ts'))) {
        output.status = 'allow';
      }
    },
  };
}

function isDangerousCommand(command: string): boolean {
  const dangerous = ['rm -rf /', 'dd if=', 'mkfs', ':(){:|:&};:'];
  return dangerous.some(d => command.includes(d));
}
```

---

## 6. 에이전트 실행 단순화

### 현재 UnifiedTaskExecutor (594줄) → TaskExecutor (~150줄)

```typescript
// src/core/agents/task-executor.ts

import type { PluginInput } from '@opencode-ai/plugin';

interface Task {
  id: string;
  sessionID: string;
  status: 'pending' | 'running' | 'completed' | 'failed';
  prompt: string;
  startedAt: number;
}

export class TaskExecutor {
  private tasks = new Map<string, Task>();
  private client: PluginInput['client'];
  private pollInterval = 2000;

  constructor(input: PluginInput) {
    this.client = input.client;
  }

  async createTask(prompt: string, parentSessionID?: string): Promise<string> {
    // 자식 세션 생성
    const session = await this.client.session.create({
      parentID: parentSessionID,
    });

    const task: Task = {
      id: crypto.randomUUID(),
      sessionID: session.id,
      status: 'pending',
      prompt,
      startedAt: Date.now(),
    };

    this.tasks.set(task.id, task);

    // 비동기 실행
    this.executeTask(task).catch(err => {
      task.status = 'failed';
      console.error(`Task ${task.id} failed:`, err);
    });

    return task.id;
  }

  private async executeTask(task: Task): Promise<void> {
    task.status = 'running';

    // 메시지 전송
    await this.client.session.prompt({
      sessionID: task.sessionID,
      parts: [{ type: 'text', text: task.prompt }],
    });

    // 완료 대기
    await this.waitForCompletion(task);
    task.status = 'completed';
  }

  private async waitForCompletion(task: Task): Promise<void> {
    return new Promise((resolve, reject) => {
      const timeout = 30 * 60 * 1000; // 30분 타임아웃
      const startTime = Date.now();

      const check = async () => {
        try {
          if (Date.now() - startTime > timeout) {
            reject(new Error('Task timeout'));
            return;
          }

          const status = await this.client.session.status({
            sessionID: task.sessionID,
          });

          if (status.status === 'idle') {
            resolve();
          } else {
            setTimeout(check, this.pollInterval);
          }
        } catch (err) {
          reject(err);
        }
      };

      check();
    });
  }

  getTask(taskId: string): Task | undefined {
    return this.tasks.get(taskId);
  }

  async cleanup(): Promise<void> {
    // 모든 실행 중인 세션 정리
    for (const task of this.tasks.values()) {
      if (task.status === 'running') {
        await this.client.session.abort({ sessionID: task.sessionID }).catch(() => {});
      }
    }
    this.tasks.clear();
  }
}
```

---

## 7. 캐시 통합

### 현재 (DocumentCache 150줄 + MemoryManager 300줄) → Cache (~80줄)

```typescript
// src/core/memory/cache.ts

interface CacheEntry<T> {
  data: T;
  expiresAt: number;
}

export class Cache {
  private store = new Map<string, CacheEntry<unknown>>();
  private cleanupTimer: NodeJS.Timeout;

  constructor(cleanupIntervalMs = 60000) {
    this.cleanupTimer = setInterval(() => this.cleanup(), cleanupIntervalMs);
  }

  set<T>(key: string, data: T, ttlMs: number): void {
    this.store.set(key, {
      data,
      expiresAt: Date.now() + ttlMs,
    });
  }

  get<T>(key: string): T | null {
    const entry = this.store.get(key);
    if (!entry) return null;
    if (Date.now() > entry.expiresAt) {
      this.store.delete(key);
      return null;
    }
    return entry.data as T;
  }

  delete(key: string): void {
    this.store.delete(key);
  }

  has(key: string): boolean {
    return this.get(key) !== null;
  }

  private cleanup(): void {
    const now = Date.now();
    for (const [key, entry] of this.store) {
      if (now > entry.expiresAt) {
        this.store.delete(key);
      }
    }
  }

  destroy(): void {
    clearInterval(this.cleanupTimer);
    this.store.clear();
  }
}

// 전역 인스턴스
export const cache = new Cache();
```

---

## 8. Rust 바이너리

### 결정: 현재 구조 유지

**변경 없음. 이유:**
- 도구별 프로세스 스폰은 격리성 제공
- IPC 복잡성 추가 대비 이점 불명확
- 현재 성능 충분

---

## 9. 삭제/변경 대상 총정리

### 9.1 완전 삭제 (~1,200줄)

| 경로 | 줄 수 | 사유 |
|------|-------|------|
| `src/core/todo/` (전체) | 599 | OpenCode Todo API 사용 |
| `src/core/tui/task-toast-manager.ts` | 89 | OpenCode 이벤트 사용 |
| `src/core/cache/document-cache.ts` | 150 | Cache로 통합 |
| `src/core/memory/memory-manager.ts` | 300 | Cache로 통합 |

### 9.2 단순화 (~1,500줄 감소)

| 파일 | 현재 | 변경 | 감소 |
|------|------|------|------|
| `src/core/loop/*` | 1,735 | ~400 | 1,335 |
| `src/hooks/registry.ts` | 200 | 60 | 140 |
| `src/core/agents/unified-task-executor.ts` | 594 | 150 | 444 |

### 9.3 .opencode 파일 삭제

```
todo.md                    # OpenCode 내장 Todo 사용
todo.version.json          # MVCC 제거
status.md                  # 삭제
sync-issues.md             # 삭제
archive/todo_history.jsonl # 삭제
archive/tasks/active_tasks.jsonl # 삭제
```

---

## 10. 신규/수정 파일

| 파일 | 줄 수 | 역할 |
|------|-------|------|
| `src/core/mission/mission-controller.ts` | 250 | 미션 제어 (OpenCode API 활용) |
| `src/core/memory/cache.ts` | 80 | 통합 캐시 |
| `src/hooks/integration.ts` | 60 | OpenCode 훅 연동 |
| `src/index.ts` (수정) | 150 | 플러그인 진입점 단순화 |

**총 신규: ~540줄**

---

## 11. 코드량 변화

| 항목 | 변화 |
|------|------|
| 완전 삭제 | -1,138 |
| 단순화 | -1,919 |
| 신규 | +540 |
| **순 감소** | **-2,517줄** |

---

## 12. 핵심 API 사용 정리

### OpenCode SDK API 사용

```typescript
// 세션 관리
client.session.create()           // ✅ 사용
client.session.get()              // ✅ 사용
client.session.status()           // ✅ 사용 (idle/busy 확인)
client.session.delete()           // ✅ 사용
client.session.children()         // ✅ 사용

// 메시지 전송
client.session.prompt()           // ✅ 사용 (핵심)
client.session.messages()         // ✅ 사용

// Todo (읽기 전용)
client.session.todo()             // ✅ 사용

// 이벤트
client.global.event()             // ✅ 사용 (SSE)
```

### OpenCode Plugin Hooks 사용

```typescript
// 메시지 처리
"chat.message"                    // ✅ 사용 (/task 감지)

// 도구 실행
"tool.execute.before"             // ✅ 사용 (검증)
"tool.execute.after"              // ✅ 사용 (모니터링)

// 이벤트 구독
"event"                           // ✅ 사용 (세션 이벤트)

// 권한
"permission.ask"                  // ⚠️ 선택적 사용
```

### 사용하지 않는 API

```typescript
// Storage API (내부 전용, 플러그인 접근 불가)
Storage.read()                    // ❌ 직접 사용 불가
Storage.write()                   // ❌ 직접 사용 불가

// Todo 업데이트 (도구를 통해서만 가능)
Todo.update()                     // ❌ 직접 사용 불가 (todowrite 도구 사용)
```

---

## 13. 구현 순서

```
1단계: MissionController 구현 (1일)
  ├── OpenCode SDK 연동
  └── 기본 미션 루프

2단계: 플러그인 진입점 수정 (0.5일)
  └── Hooks 연동

3단계: 기존 코드 정리 (1일)
  ├── src/core/todo/ 삭제
  ├── src/core/loop/ 단순화
  └── .opencode 파일 정리

4단계: TaskExecutor 단순화 (1일)
  └── SDK API 활용

5단계: 캐시 통합 (0.5일)
  └── Cache 클래스로 통합

6단계: 테스트 및 정리 (2일)
  ├── E2E 테스트
  └── Dead code 제거
```

**총 소요: 6일**

---

## 14. 결론

### 이전 제안 vs 현재 제안 (수정됨)

| 항목 | 이전 제안 | 현재 제안 (수정) |
|------|----------|-----------------|
| TODO 관리 | `client.session.todo.update()` (가정) | `client.session.todo()` (읽기) + LLM todowrite |
| 상태 저장 | `client.storage.write()` (가정) | 최소 파일 또는 세션 메타데이터 |
| TUI 업데이트 | `client.event.emit()` (가정) | OpenCode 내장 이벤트 (자동) |
| 세션 관리 | 자체 구현 | `client.session.*` API |

### 핵심 변화

1. **현실 반영**: OpenCode SDK의 실제 API를 기반으로 설계
2. **Todo 업데이트**: 플러그인에서 직접 불가 → LLM이 `todowrite` 도구 호출
3. **Storage 접근**: 플러그인에서 직접 불가 → 세션 메타데이터 또는 최소 파일 사용
4. **훅 시스템**: OpenCode 네이티브 `Hooks` 인터페이스 활용

### 총 효과

| 항목 | 결과 |
|------|------|
| 코드 감소 | ~2,500줄 |
| 파일 감소 | ~15개 |
| 복잡도 | 대폭 감소 |
| 유지보수성 | 향상 |
